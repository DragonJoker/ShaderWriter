/*
See LICENSE file in root folder
*/
/*
This file is generated, don't modify it!
*/
#ifndef ___AST_ExprMakeSampledImageAccess_H___
#define ___AST_ExprMakeSampledImageAccess_H___
#pragma once

#include "ExprSampledImageAccessCall.hpp"

#include <cassert>

namespace ast::expr
{	// Texel Lookup Functions

	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DFBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample1DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DFBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample1DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DFBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample1DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DFBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample1DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample1DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample1DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DFBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample2DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DFBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample2DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DFBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample2DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DFBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample2DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample2DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample2DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DFBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DFBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DFBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DFBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeFBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleCubeFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeFBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleCubeFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeFBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleCubeFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeFBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleCubeFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleCubeFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleCubeFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayFBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample1DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayFBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample1DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayFBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample1DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayFBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample1DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample1DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample1DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayFBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample2DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayFBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample2DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayFBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample2DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayFBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample2DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample2DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample2DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayFBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleCubeArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayFBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleCubeArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayFBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleCubeArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayFBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleCubeArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleCubeArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleCubeArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSample2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSample2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DIBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample1DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DIBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample1DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DIBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample1DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DIBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample1DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DIBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample1DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DIBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample1DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DIBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample1DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DIBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample1DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DIBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample1DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DIBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample2DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DIBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample2DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DIBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample2DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DIBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample2DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DIBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample2DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DIBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample2DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DIBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample2DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DIBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample2DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DIBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample2DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DIBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DIBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DIBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DIBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DIBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DIBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DIBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DIBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DIBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeIBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleCubeIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeIBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleCubeIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeIBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleCubeIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeIBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleCubeIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeIBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleCubeIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeIBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleCubeIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeIBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleCubeIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeIBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleCubeIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeIBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleCubeIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayIBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample1DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayIBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample1DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayIBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample1DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayIBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample1DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayIBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample1DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayIBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample1DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayIBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample1DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayIBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample1DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayIBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample1DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayIBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample2DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayIBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample2DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayIBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample2DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayIBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample2DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayIBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample2DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayIBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample2DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayIBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample2DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayIBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample2DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayIBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample2DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayIBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleCubeArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayIBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleCubeArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayIBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleCubeArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayIBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleCubeArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayIBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleCubeArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayIBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleCubeArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayIBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleCubeArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayIBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleCubeArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayIBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleCubeArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSample2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSample2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSample2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DUBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample1DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DUBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample1DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DUBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample1DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DUBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample1DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DUBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample1DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DUBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample1DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DUBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample1DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DUBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample1DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DUBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample1DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DUBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample2DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DUBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample2DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DUBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample2DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DUBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample2DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DUBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample2DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DUBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample2DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DUBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample2DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DUBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample2DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DUBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample2DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample3DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DUBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DUBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DUBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DUBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DUBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DUBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DUBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DUBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample3DUBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeUBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleCubeUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeUBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleCubeUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeUBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleCubeUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeUBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleCubeUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeUBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleCubeUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeUBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleCubeUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeUBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleCubeUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeUBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleCubeUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeUBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleCubeUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayUBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample1DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayUBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample1DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayUBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample1DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayUBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample1DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayUBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample1DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayUBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample1DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayUBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample1DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayUBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample1DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayUBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample1DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayUBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample2DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayUBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample2DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayUBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample2DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayUBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample2DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayUBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample2DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayUBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample2DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayUBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample2DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayUBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample2DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayUBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample2DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayUBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleCubeArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayUBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleCubeArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayUBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleCubeArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayUBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleCubeArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayUBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleCubeArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayUBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleCubeArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayUBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleCubeArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayUBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleCubeArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayUBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleCubeArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSample2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSample2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSample2DRectUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSample2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF2Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF2Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF2Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF2Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF2R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF2R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF2BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj1DF2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF2BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj1DF2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF2BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj1DF2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF2BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj1DF2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF2BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj1DF2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF2BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj1DF2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF4BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj1DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF4BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj1DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF4BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj1DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF4BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj1DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF4BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj1DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DF4BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj1DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF3BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj2DF3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF3BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj2DF3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF3BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj2DF3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF3BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj2DF3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF3BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj2DF3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF3BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj2DF3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF4BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj2DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF4BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj2DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF4BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj2DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF4BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj2DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF4BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj2DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DF4BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj2DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DFBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DFBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DFBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DFBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectF3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectF3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectF3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectF3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectF3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectF3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectF4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectF4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProj2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectF4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectF4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProj2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectF4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectF4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI2Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI2Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI2Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI2Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI2Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI2Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI2R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI2R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI2R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI2BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj1DI2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI2BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj1DI2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI2BiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj1DI2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI2BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj1DI2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI2BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj1DI2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI2BiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj1DI2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI2BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj1DI2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI2BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj1DI2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI2BiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj1DI2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI4BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj1DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI4BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj1DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI4BiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj1DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI4BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj1DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI4BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj1DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI4BiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj1DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI4BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj1DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI4BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj1DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DI4BiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj1DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI3BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj2DI3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI3BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj2DI3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI3BiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj2DI3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI3BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj2DI3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI3BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj2DI3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI3BiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj2DI3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI3BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj2DI3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI3BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj2DI3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI3BiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj2DI3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI4BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj2DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI4BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj2DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI4BiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj2DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI4BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj2DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI4BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj2DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI4BiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj2DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI4BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj2DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI4BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj2DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DI4BiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj2DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DIBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DIBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DIBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DIBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DIBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DIBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DIBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DIBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DIBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectI3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectI3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectI3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectI3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectI3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectI3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectI3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectI3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectI3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectI4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectI4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectI4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProj2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectI4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectI4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectI4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProj2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectI4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectI4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectI4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProj2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU2Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU2Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU2Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU2Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU2Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU2Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU2R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU2R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU2R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU2BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj1DU2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU2BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj1DU2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU2BiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj1DU2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU2BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj1DU2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU2BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj1DU2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU2BiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj1DU2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU2BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj1DU2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU2BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj1DU2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU2BiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj1DU2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU4BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj1DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU4BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj1DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU4BiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj1DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU4BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj1DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU4BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj1DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU4BiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj1DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU4BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj1DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU4BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj1DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DU4BiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj1DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU3BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj2DU3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU3BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj2DU3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU3BiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj2DU3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU3BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj2DU3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU3BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj2DU3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU3BiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj2DU3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU3BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj2DU3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU3BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj2DU3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU3BiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj2DU3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU4BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj2DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU4BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj2DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU4BiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj2DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU4BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj2DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU4BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj2DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU4BiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj2DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU4BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj2DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU4BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj2DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DU4BiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj2DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DUBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DUBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DUBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DUBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DUBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DUBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DUBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DUBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj3DUBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectU3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectU3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectU3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectU3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectU3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectU3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectU3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectU3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectU3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectU4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectU4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectU4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProj2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectU4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectU4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectU4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProj2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectU4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectU4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectU4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProj2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLod1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLod1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLod1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLod1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLod1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLod1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLod2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLod2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLod2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLod2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLod2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLod2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLod3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLod3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLod3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLod3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLod3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLod3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLodCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLodCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLodCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLodCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLod1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLod1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLod1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLod1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLod1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLod1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLod2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLod2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLod2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLod2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLod2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLod2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLodCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLodCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLodCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLodCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLod1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLod1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLod1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLod1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLod1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLod1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLod1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLod1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLod1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLod2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLod2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLod2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLod2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLod2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLod2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLod2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLod2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLod2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLod3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLod3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLod3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLod3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLod3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLod3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLod3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLod3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLod3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLod1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLod1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLod1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLod1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLod1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLod1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLod1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLod1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLod1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLod2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLod2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLod2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLod2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLod2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLod2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLod2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLod2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLod2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLod1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLod1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLod1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLod1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLod1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLod1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLod1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLod1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLod1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLod2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLod2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLod2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLod2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLod2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLod2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLod2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLod2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLod2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLod3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLod3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLod3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLod3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLod3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLod3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLod3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLod3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod3DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLod3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLod1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLod1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLod1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLod1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLod1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLod1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLod1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLod1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLod1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLod2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLod2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLod2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLod2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLod2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLod2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLod2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLod2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLod2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLodCubeArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DFBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset1DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DFBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset1DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DFBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset1DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DFBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset1DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset1DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset1DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DFBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset2DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DFBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset2DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DFBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset2DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DFBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset2DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset2DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset2DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DFBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DFBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DFBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DFBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayFBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset1DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayFBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset1DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayFBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset1DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayFBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset1DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset1DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset1DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayFBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset2DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayFBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleOffset2DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayFBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset2DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayFBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleOffset2DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset2DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset2DArrayFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DIBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset1DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DIBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset1DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DIBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset1DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DIBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset1DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DIBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset1DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DIBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset1DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DIBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset1DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DIBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset1DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DIBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset1DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DIBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset2DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DIBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset2DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DIBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset2DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DIBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset2DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DIBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset2DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DIBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset2DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DIBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset2DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DIBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset2DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DIBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset2DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DIBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DIBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DIBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DIBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DIBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DIBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DIBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DIBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DIBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayIBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset1DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayIBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset1DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayIBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset1DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayIBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset1DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayIBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset1DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayIBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset1DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayIBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset1DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayIBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset1DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayIBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset1DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayIBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset2DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayIBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset2DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayIBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleOffset2DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayIBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset2DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayIBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset2DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayIBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleOffset2DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayIBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset2DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayIBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset2DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayIBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleOffset2DArrayIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DUBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset1DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DUBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset1DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DUBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset1DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DUBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset1DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DUBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset1DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DUBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset1DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DUBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset1DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DUBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset1DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DUBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset1DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DUBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset2DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DUBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset2DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DUBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset2DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DUBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset2DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DUBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset2DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DUBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset2DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DUBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset2DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DUBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset2DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DUBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset2DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DUBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DUBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DUBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DUBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DUBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DUBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DUBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DUBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset3DUBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayUBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset1DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayUBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset1DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayUBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset1DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayUBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset1DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayUBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset1DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayUBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset1DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayUBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset1DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayUBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset1DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayUBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset1DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayUBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset2DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayUBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset2DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayUBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleOffset2DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayUBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset2DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayUBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset2DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayUBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleOffset2DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayUBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset2DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayUBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset2DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayUBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleOffset2DArrayUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF2Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF2Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF2Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF2Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF2R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF2R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF2BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset1DF2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF2BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset1DF2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF2BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset1DF2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF2BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset1DF2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF2BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset1DF2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF2BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset1DF2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF4BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset1DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF4BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset1DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF4BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset1DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF4BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset1DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF4BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset1DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DF4BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset1DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF3BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset2DF3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF3BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset2DF3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF3BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset2DF3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF3BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset2DF3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF3BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset2DF3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF3BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset2DF3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF4BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset2DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF4BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset2DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF4BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset2DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF4BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset2DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF4BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset2DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DF4BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset2DF4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DFBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DFBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DFBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DFBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset3DFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectF3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectF3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectF3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectF3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectF3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectF3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectF4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectF4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjOffset2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectF4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectF4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjOffset2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectF4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectF4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI2Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI2Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI2Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI2Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI2Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI2Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI2R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI2R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI2R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI2BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset1DI2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI2BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset1DI2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI2BiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset1DI2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI2BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset1DI2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI2BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset1DI2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI2BiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset1DI2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI2BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset1DI2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI2BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset1DI2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI2BiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset1DI2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI4BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset1DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI4BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset1DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI4BiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset1DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI4BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset1DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI4BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset1DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI4BiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset1DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI4BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset1DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI4BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset1DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DI4BiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset1DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI3BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset2DI3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI3BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset2DI3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI3BiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset2DI3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI3BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset2DI3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI3BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset2DI3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI3BiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset2DI3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI3BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset2DI3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI3BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset2DI3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI3BiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset2DI3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI4BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset2DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI4BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset2DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI4BiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset2DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI4BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset2DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI4BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset2DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI4BiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset2DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI4BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset2DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI4BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset2DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DI4BiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset2DI4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DIBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DIBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DIBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DIBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DIBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DIBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DIBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DIBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DIBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset3DIBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectI3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectI3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectI3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectI3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectI3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectI3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectI3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectI3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectI3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectI4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectI4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectI4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjOffset2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectI4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectI4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectI4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjOffset2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectI4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectI4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectI4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjOffset2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU2Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU2Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU2Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU2Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU2Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU2Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU2R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU2R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU2R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU2BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset1DU2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU2BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset1DU2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU2BiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset1DU2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU2BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset1DU2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU2BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset1DU2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU2BiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset1DU2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU2BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset1DU2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU2BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset1DU2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU2BiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset1DU2Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU4BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset1DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU4BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset1DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU4BiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset1DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU4BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset1DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU4BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset1DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU4BiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset1DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU4BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset1DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU4BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset1DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DU4BiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset1DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU3BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset2DU3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU3BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset2DU3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU3BiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset2DU3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU3BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset2DU3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU3BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset2DU3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU3BiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset2DU3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU3BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset2DU3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU3BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset2DU3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU3BiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset2DU3Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU4BiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset2DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU4BiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset2DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU4BiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset2DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU4BiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset2DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU4BiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset2DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU4BiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset2DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU4BiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset2DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU4BiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset2DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DU4BiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset2DU4Bias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DUBiasRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DUBiasRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DUBiasRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DUBiasRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DUBiasRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DUBiasRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DUBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DUBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset3DUBiasR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset3DUBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectU3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectU3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectU3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectU3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectU3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectU3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectU3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectU3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectU3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectU4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectU4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectU4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjOffset2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectU4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectU4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectU4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjOffset2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectU4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectU4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectU4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjOffset2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLodOffset1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLodOffset1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLodOffset1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLodOffset1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodOffset1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodOffset1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLodOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLodOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLodOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLodOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLodOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLodOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLodOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLodOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLodOffset1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLodOffset1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLodOffset1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLodOffset1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodOffset1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodOffset1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLodOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleLodOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLodOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleLodOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleLodOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleLodOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleLodOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset3DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleLodOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleLodOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleLodOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DF2Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLod1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DF2Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLod1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DF2Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLod1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DF2Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLod1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DF2R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLod1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DF2R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLod1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DF4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLod1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DF4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLod1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DF4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLod1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DF4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLod1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DF4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLod1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DF4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLod1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DF3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLod2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DF3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLod2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DF3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLod2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DF3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLod2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DF3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLod2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DF3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLod2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DF4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLod2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DF4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLod2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DF4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLod2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DF4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLod2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DF4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLod2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DF4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLod2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLod3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLod3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLod3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLod3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLod3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLod3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DI2Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLod1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DI2Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLod1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DI2Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLod1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DI2Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLod1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DI2Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLod1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DI2Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLod1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DI2R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLod1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DI2R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLod1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DI2R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLod1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DI4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLod1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DI4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLod1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DI4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLod1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DI4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLod1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DI4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLod1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DI4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLod1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DI4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLod1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DI4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLod1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DI4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLod1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DI3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLod2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DI3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLod2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DI3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLod2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DI3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLod2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DI3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLod2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DI3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLod2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DI3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLod2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DI3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLod2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DI3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLod2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DI4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLod2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DI4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLod2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DI4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLod2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DI4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLod2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DI4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLod2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DI4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLod2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DI4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLod2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DI4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLod2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DI4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLod2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLod3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLod3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLod3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLod3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLod3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLod3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLod3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLod3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLod3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DU2Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLod1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DU2Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLod1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DU2Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLod1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DU2Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLod1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DU2Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLod1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DU2Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLod1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DU2R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLod1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DU2R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLod1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DU2R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLod1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DU4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLod1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DU4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLod1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DU4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLod1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DU4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLod1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DU4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLod1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DU4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLod1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DU4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLod1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DU4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLod1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DU4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLod1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DU3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLod2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DU3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLod2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DU3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLod2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DU3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLod2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DU3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLod2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DU3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLod2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DU3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLod2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DU3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLod2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DU3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLod2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DU4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLod2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DU4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLod2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DU4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLod2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DU4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLod2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DU4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLod2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DU4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLod2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DU4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLod2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DU4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLod2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DU4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLod2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLod3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLod3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLod3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLod3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLod3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLod3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLod3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLod3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod3DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLod3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DF2Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLodOffset1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DF2Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLodOffset1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DF2Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLodOffset1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DF2Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLodOffset1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DF2R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLodOffset1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DF2R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLodOffset1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DF4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLodOffset1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DF4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLodOffset1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DF4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLodOffset1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DF4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLodOffset1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DF4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLodOffset1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DF4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLodOffset1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DF3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLodOffset2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DF3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLodOffset2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DF3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLodOffset2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DF3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLodOffset2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DF3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLodOffset2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DF3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLodOffset2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DF4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLodOffset2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DF4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLodOffset2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DF4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLodOffset2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DF4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLodOffset2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DF4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLodOffset2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DF4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLodOffset2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLodOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjLodOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLodOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjLodOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLodOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLodOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DI2Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLodOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DI2Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLodOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DI2Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLodOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DI2Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLodOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DI2Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLodOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DI2Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLodOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DI2R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLodOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DI2R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLodOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DI2R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLodOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DI4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLodOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DI4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLodOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DI4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLodOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DI4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLodOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DI4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLodOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DI4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLodOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DI4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLodOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DI4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLodOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DI4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLodOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DI3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLodOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DI3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLodOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DI3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLodOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DI3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLodOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DI3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLodOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DI3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLodOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DI3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLodOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DI3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLodOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DI3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLodOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DI4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLodOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DI4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLodOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DI4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLodOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DI4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLodOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DI4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLodOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DI4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLodOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DI4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLodOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DI4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLodOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DI4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLodOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLodOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLodOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjLodOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLodOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLodOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjLodOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLodOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLodOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjLodOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DU2Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLodOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DU2Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLodOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DU2Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLodOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DU2Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLodOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DU2Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLodOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DU2Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLodOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DU2R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLodOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DU2R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLodOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DU2R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLodOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DU4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLodOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DU4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLodOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DU4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLodOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DU4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLodOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DU4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLodOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DU4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLodOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DU4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLodOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DU4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLodOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DU4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLodOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DU3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLodOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DU3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLodOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DU3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLodOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DU3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLodOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DU3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLodOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DU3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLodOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DU3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLodOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DU3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLodOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DU3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLodOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DU4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLodOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DU4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLodOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DU4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLodOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DU4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLodOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DU4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLodOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DU4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLodOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DU4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLodOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DU4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLodOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DU4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLodOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLodOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLodOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjLodOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLodOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLodOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjLodOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLodOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLodOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset3DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjLodOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGrad1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGrad1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGrad1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGrad1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGrad2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGrad2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGrad2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGrad2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGrad3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGrad3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGrad3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGrad3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGradCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGradCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGradCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGradCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGrad2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGrad2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGrad2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGrad2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGrad1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGrad1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGrad1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGrad1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGrad2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGrad2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGrad2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGrad2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGradCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGradCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGradCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGradCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGrad1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGrad1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGrad1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGrad1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGrad1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGrad1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGrad1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGrad1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGrad1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGrad2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGrad2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGrad2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGrad2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGrad2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGrad2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGrad2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGrad2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGrad2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGrad3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGrad3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGrad3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGrad3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGrad3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGrad3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGrad3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGrad3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGrad3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGrad2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGrad2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGrad2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGrad2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGrad2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGrad2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGrad2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGrad2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGrad2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGrad1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGrad1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGrad1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGrad1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGrad1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGrad1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGrad1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGrad1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGrad1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGrad2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGrad2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGrad2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGrad2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGrad2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGrad2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGrad2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGrad2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGrad2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGrad1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGrad1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGrad1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGrad1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGrad1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGrad1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGrad1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGrad1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGrad1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGrad2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGrad2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGrad2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGrad2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGrad2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGrad2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGrad2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGrad2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGrad2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGrad3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGrad3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGrad3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGrad3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGrad3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGrad3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGrad3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGrad3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad3DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGrad3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGrad2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGrad2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGrad2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGrad2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGrad2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGrad2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGrad2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGrad2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGrad2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGrad1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGrad1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGrad1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGrad1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGrad1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGrad1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGrad1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGrad1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGrad1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGrad2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGrad2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGrad2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGrad2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGrad2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGrad2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGrad2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGrad2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGrad2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleGradCubeArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGradOffset1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGradOffset1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGradOffset1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGradOffset1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset1DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGradOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGradOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGradOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGradOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGradOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGradOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGradOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGradOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGradOffset2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGradOffset2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGradOffset2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGradOffset2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGradOffset1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGradOffset1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGradOffset1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGradOffset1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset1DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGradOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGradOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGradOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleGradOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradOffset1DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradOffset1DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGradOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleGradOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleGradOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradOffset1DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset3DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradOffset1DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGradOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleGradOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleGradOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DF2Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGrad1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DF2Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGrad1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DF2Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGrad1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DF2Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGrad1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DF2R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DF2R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DF4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGrad1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DF4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGrad1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DF4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGrad1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DF4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGrad1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DF4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DF4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DF3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGrad2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DF3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGrad2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DF3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGrad2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DF3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGrad2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DF3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DF3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DF4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGrad2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DF4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGrad2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DF4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGrad2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DF4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGrad2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DF4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DF4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGrad3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGrad3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGrad3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGrad3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectF3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGrad2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectF3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGrad2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectF3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGrad2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectF3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGrad2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectF3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectF3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectF4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGrad2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectF4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGrad2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectF4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGrad2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectF4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGrad2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectF4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectF4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DI2Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DI2Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DI2Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DI2Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DI2Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DI2Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DI2R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DI2R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DI2R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DI4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DI4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DI4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DI4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DI4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DI4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DI4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DI4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DI4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DI3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DI3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DI3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DI3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DI3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DI3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DI3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DI3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DI3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DI4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DI4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DI4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DI4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DI4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DI4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DI4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DI4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DI4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectI3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectI3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectI3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectI3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectI3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectI3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectI3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectI3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectI3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectI4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectI4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectI4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGrad2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectI4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectI4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectI4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGrad2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectI4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectI4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectI4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGrad2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DU2Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DU2Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DU2Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DU2Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DU2Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DU2Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DU2R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DU2R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DU2R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DU4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DU4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DU4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DU4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DU4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DU4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DU4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DU4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DU4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DU3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DU3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DU3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DU3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DU3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DU3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DU3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DU3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DU3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DU4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DU4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DU4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DU4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DU4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DU4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DU4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DU4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DU4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad3DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectU3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectU3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectU3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectU3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectU3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectU3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectU3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectU3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectU3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectU4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectU4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectU4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGrad2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectU4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectU4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectU4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGrad2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectU4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectU4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectU4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGrad2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DF2Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGradOffset1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DF2Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGradOffset1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DF2Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGradOffset1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DF2Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGradOffset1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DF2R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DF2R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset1DF2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DF4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGradOffset1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DF4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGradOffset1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DF4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGradOffset1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DF4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGradOffset1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DF4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DF4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset1DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DF3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGradOffset2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DF3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGradOffset2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DF3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGradOffset2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DF3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGradOffset2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DF3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DF3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset2DF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DF4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGradOffset2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DF4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGradOffset2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DF4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGradOffset2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DF4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGradOffset2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DF4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DF4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset2DF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGradOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGradOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGradOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGradOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset3DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectF3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGradOffset2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectF3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGradOffset2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectF3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGradOffset2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectF3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGradOffset2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectF3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectF3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset2DRectF3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectF4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGradOffset2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectF4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleProjGradOffset2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectF4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGradOffset2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectF4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, SampledImageAccess::eSampleProjGradOffset2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectF4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectF4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset2DRectF4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DI2Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DI2Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DI2Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DI2Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DI2Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DI2Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DI2R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DI2R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DI2R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset1DI2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DI4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DI4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DI4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DI4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DI4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DI4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DI4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DI4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DI4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset1DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DI3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DI3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DI3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DI3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DI3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DI3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DI3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DI3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DI3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset2DI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DI4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DI4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DI4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DI4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DI4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DI4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DI4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DI4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DI4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset2DI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset3DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectI3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectI3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectI3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectI3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectI3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectI3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectI3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectI3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectI3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset2DRectI3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectI4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectI4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectI4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleProjGradOffset2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectI4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectI4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectI4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, SampledImageAccess::eSampleProjGradOffset2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectI4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectI4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectI4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eInt )
			, SampledImageAccess::eSampleProjGradOffset2DRectI4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DU2Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DU2Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DU2Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DU2Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DU2Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DU2Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DU2R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DU2R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DU2R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset1DU2
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DU4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DU4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DU4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DU4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DU4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DU4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DU4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DU4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 1D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DU4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset1DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DU3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DU3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DU3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DU3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DU3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DU3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DU3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DU3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DU3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset2DU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DU4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DU4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DU4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DU4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DU4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DU4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DU4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DU4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DU4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset2DU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, 3D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset3DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset3DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectU3Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectU3Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectU3Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectU3Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectU3Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectU3Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectU3R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectU3R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectU3R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset2DRectU3
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectU4Rgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectU4Rgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectU4Rgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleProjGradOffset2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectU4Rg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectU4Rg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectU4Rg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, SampledImageAccess::eSampleProjGradOffset2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectU4R32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectU4R16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectU4R8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eUInt )
			, SampledImageAccess::eSampleProjGradOffset2DRectU4
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}	
	// Texel Compare Functions

	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DShadowFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample1DShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DShadowFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample1DShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DShadowFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample2DShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DShadowFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample2DShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleCubeShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleCubeShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeShadowFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleCubeShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeShadowFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleCubeShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample1DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample1DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayShadowFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample1DArrayShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample1DArrayShadowFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample1DArrayShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample2DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample2DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSample2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSample2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleCubeArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Cube, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleCubeArrayShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleCubeArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DShadowFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj1DShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj1DShadowFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj1DShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DShadowFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj2DShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DShadowFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj2DShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProj2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProj2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLod1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLod1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLod2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod2DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLod2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLod1DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleLod1DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLod1DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DShadowFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset1DShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DShadowFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset1DShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DShadowFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset2DShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DShadowFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset2DShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset1DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleOffset1DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset1DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset2DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleOffset2DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleOffset2DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DShadowFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset1DShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset1DShadowFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset1DShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DShadowFBiasR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset2DShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DShadowFBiasR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset2DShadowFBias
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjOffset2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjOffset2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodOffset1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodOffset1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodOffset2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset2DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodOffset2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodOffset1DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleLodOffset1DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleLodOffset1DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLod1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod1DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLod1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLod2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjLod2DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLod2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLodOffset1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset1DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLodOffset1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLodOffset2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjLodOffset2DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjLodOffset2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleGrad2DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad1DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGrad1DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGrad1DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset1DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset1DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset1DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset2DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGradOffset2DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleGradOffset2DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad1DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline SampledImageAccessCallPtr makeSampleProjGrad2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGrad2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 1D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset1DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset1DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleProjGradOffset2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eFloat )
			, SampledImageAccess::eSampleProjGradOffset2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	// Texture Gather Functions

	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherCubeF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherCubeArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherCubeI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherCubeArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGather2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherCubeU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Cube, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherCubeArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGather2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffset2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffset2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DArrayF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectFRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectFRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectFRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectFRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DRectF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DArrayI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectIRgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectIRgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectIRgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectIRg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectIRg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectIRg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectIR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectIR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	SampledImage<Int, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectIR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, SampledImageAccess::eSampleGatherOffsets2DRectI
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, 2D, Array>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DArrayU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectURgba32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectURgba16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectURgba8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectURg32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectURg16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectURg8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectUR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectUR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	SampledImage<UInt, Rect>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectUR8( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, SampledImageAccess::eSampleGatherOffsets2DRectU
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	// Texture Gather Compare Functions

	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherCubeShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherCubeShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherCubeArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Cube, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec4f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGatherCubeArrayShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherCubeArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline SampledImageAccessCallPtr makeSampleGather2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGather2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffset2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffset2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, 2D, Array, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DArrayShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	SampledImage<Float, Rect, Shadow>
	*@param sampler
	*	Sampler
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offsets
	*	vec2i
	*/
	inline SampledImageAccessCallPtr makeSampleGatherOffsets2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr image
		, ExprPtr sampler
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeSampledImageAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, SampledImageAccess::eSampleGatherOffsets2DRectShadowF
			, std::move( image )
			, std::move( sampler )
			, std::move( P )
			, std::move( refZ )
			, std::move( offsets ) );
	}
}

#endif
