/*
See LICENSE file in root folder
*/
/*
This file is generated, don't modify it!
*/
#ifndef ___AST_ExprMakeCombinedImageAccess_H___
#define ___AST_ExprMakeCombinedImageAccess_H___
#pragma once

#include "ExprCache.hpp"
#include "ExprCombinedImageAccessCall.hpp"

#include <cassert>

namespace ast::expr
{	// Texture Query Functions

	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, Cube, Shadow>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, Cube, Shadow>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, Cube, Array, Shadow>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, Cube, Array, Shadow>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSize1DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize2DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize3DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize3DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSizeCubeU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeCubeArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSizeCubeArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize1DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureSize1DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureSize2DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec3I )
			, CombinedImageAccess::eTextureSize2DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Buffer>
	*/
	inline CombinedImageAccessCallPtr makeTextureSizeBufferUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureSizeBufferU
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube, Shadow>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube, Shadow>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube, Array, Shadow>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube, Array, Shadow>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod3DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod1DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLod2DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLod2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLodCubeArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureQueryLodCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Cube, Shadow>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Cube, Shadow>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Cube, Array, Shadow>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Float, Cube, Array, Shadow>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 2D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 3D>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels3DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels3DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Cube>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels1DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels1DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevels2DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevels2DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*/
	inline CombinedImageAccessCallPtr makeTextureQueryLevelsCubeArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture )
	{
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureQueryLevelsCubeArrayU
			, std::move( texture ) );
	}
	// Texel Lookup Functions

	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DFBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DFBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DFBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DFBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DFBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DFBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DFBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DFBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DFBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DFBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DFBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DFBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeFBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureCubeFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeFBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureCubeFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeFBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureCubeFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeFBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureCubeFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureCubeFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureCubeFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayFBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayFBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayFBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayFBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayFBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayFBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexture2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayFBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayFBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexture2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayFBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureCubeArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayFBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureCubeArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayFBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureCubeArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayFBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureCubeArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureCubeArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureCubeArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DIBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DIBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DIBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DIBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DIBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DIBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DIBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DIBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DIBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DIBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DIBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DIBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DIBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DIBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DIBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DIBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DIBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DIBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DIBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DIBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DIBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DIBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DIBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DIBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DIBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DIBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DIBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeIBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureCubeIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeIBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureCubeIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeIBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureCubeIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeIBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureCubeIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeIBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureCubeIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeIBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureCubeIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeIBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureCubeIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeIBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureCubeIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeIBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureCubeIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayIBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayIBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayIBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayIBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayIBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayIBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayIBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayIBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayIBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayIBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayIBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayIBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexture2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayIBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayIBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayIBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexture2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayIBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayIBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayIBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexture2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayIBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureCubeArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayIBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureCubeArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayIBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureCubeArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayIBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureCubeArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayIBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureCubeArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayIBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureCubeArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayIBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureCubeArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayIBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureCubeArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayIBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureCubeArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DUBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DUBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DUBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DUBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DUBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DUBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DUBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DUBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DUBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DUBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DUBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DUBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DUBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DUBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DUBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DUBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DUBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DUBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture3DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DUBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DUBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DUBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DUBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DUBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DUBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DUBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DUBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture3DUBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeUBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureCubeUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeUBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureCubeUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeUBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureCubeUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeUBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureCubeUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeUBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureCubeUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeUBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureCubeUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeUBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureCubeUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeUBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureCubeUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeUBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureCubeUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayUBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayUBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayUBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayUBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayUBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayUBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayUBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayUBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayUBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayUBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayUBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayUBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexture2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayUBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayUBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayUBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexture2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayUBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayUBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayUBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexture2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayUBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureCubeArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayUBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureCubeArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayUBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureCubeArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayUBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureCubeArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayUBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureCubeArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayUBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureCubeArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayUBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureCubeArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayUBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureCubeArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayUBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureCubeArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF2Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj1DF2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF2Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj1DF2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF2Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj1DF2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF2Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj1DF2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF2R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj1DF2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF2R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj1DF2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF2BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF2BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF2BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF2BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF2BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF2BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj1DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj1DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj1DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj1DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj1DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj1DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF4BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF4BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF4BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF4BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF4BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DF4BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF3Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj2DF3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF3Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj2DF3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF3Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj2DF3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF3Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj2DF3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF3R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj2DF3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF3R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj2DF3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF3BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF3BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF3BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF3BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF3BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF3BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj2DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj2DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj2DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj2DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj2DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj2DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF4BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF4BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF4BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF4BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF4BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DF4BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DFBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DFBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProj3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DFBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DFBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProj3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI2Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj1DI2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI2Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj1DI2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI2Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj1DI2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI2Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj1DI2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI2Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj1DI2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI2Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj1DI2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI2R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj1DI2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI2R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj1DI2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI2R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj1DI2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI2BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI2BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI2BiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI2BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI2BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI2BiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI2BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI2BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI2BiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj1DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj1DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj1DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj1DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj1DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj1DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj1DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj1DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj1DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI4BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI4BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI4BiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI4BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI4BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI4BiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI4BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI4BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DI4BiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI3Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj2DI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI3Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj2DI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI3Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj2DI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI3Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj2DI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI3Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj2DI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI3Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj2DI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI3R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj2DI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI3R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj2DI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI3R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj2DI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI3BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI3BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI3BiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI3BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI3BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI3BiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI3BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI3BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI3BiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj2DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj2DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj2DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj2DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj2DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj2DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj2DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj2DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj2DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI4BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI4BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI4BiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI4BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI4BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI4BiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI4BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI4BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DI4BiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DIBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DIBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DIBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProj3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DIBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DIBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DIBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProj3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DIBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DIBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DIBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProj3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU2Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj1DU2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU2Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj1DU2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU2Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj1DU2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU2Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj1DU2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU2Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj1DU2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU2Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj1DU2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU2R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj1DU2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU2R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj1DU2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU2R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj1DU2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU2BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU2BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU2BiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU2BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU2BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU2BiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU2BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU2BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU2BiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj1DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj1DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj1DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj1DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj1DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj1DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj1DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj1DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj1DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU4BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU4BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU4BiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU4BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU4BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU4BiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU4BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU4BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DU4BiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU3Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj2DU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU3Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj2DU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU3Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj2DU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU3Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj2DU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU3Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj2DU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU3Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj2DU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU3R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj2DU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU3R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj2DU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU3R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj2DU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU3BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU3BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU3BiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU3BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU3BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU3BiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU3BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU3BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU3BiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj2DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj2DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj2DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj2DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj2DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj2DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj2DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj2DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj2DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU4BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU4BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU4BiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU4BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU4BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU4BiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU4BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU4BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DU4BiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DUBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DUBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DUBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProj3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DUBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DUBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DUBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProj3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DUBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DUBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj3DUBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProj3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLod1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLod1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLod1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLod1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLod1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLod1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLod2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLod2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLod2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLod2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLod2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLod2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLodCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLodCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLodCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLodCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLod1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLod1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLod1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLod1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLod1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLod1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLod2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLod2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLod2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLod2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLod2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLod2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLodCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLodCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLodCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLodCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLod1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLod1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLod1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLod1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLod1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLod1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLod1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLod1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLod1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLod2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLod2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLod2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLod2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLod2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLod2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLod2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLod2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLod2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLod1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLod1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLod1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLod1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLod1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLod1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLod1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLod1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLod1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLod2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLod2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLod2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLod2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLod2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLod2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLod2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLod2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLod2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLod1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLod1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLod1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLod1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLod1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLod1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLod1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLod1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLod1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLod2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLod2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLod2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLod2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLod2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLod2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLod2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLod2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLod2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod3DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLod1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLod1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLod1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLod1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLod1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLod1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLod1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLod1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLod1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLod2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLod2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLod2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLod2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLod2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLod2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLod2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLod2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLod2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DFBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DFBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DFBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DFBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DFBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DFBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DFBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DFBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DFBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DFBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DFBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DFBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayFBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayFBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayFBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayFBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayFBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayFBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureOffset2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayFBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayFBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureOffset2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DIBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DIBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DIBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DIBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DIBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DIBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DIBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DIBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DIBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DIBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DIBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DIBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DIBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DIBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DIBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DIBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DIBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DIBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DIBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DIBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DIBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DIBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DIBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DIBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DIBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DIBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DIBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayIBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayIBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayIBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayIBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayIBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayIBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayIBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayIBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayIBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayIBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayIBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayIBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureOffset2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayIBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayIBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayIBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureOffset2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayIBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayIBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayIBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureOffset2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DUBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DUBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DUBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DUBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DUBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DUBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DUBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DUBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DUBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DUBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DUBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DUBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DUBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DUBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DUBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DUBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DUBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DUBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DUBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DUBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DUBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DUBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DUBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DUBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DUBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DUBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset3DUBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayUBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayUBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayUBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayUBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayUBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayUBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayUBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayUBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayUBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayUBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayUBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayUBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureOffset2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayUBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayUBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayUBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureOffset2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayUBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayUBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayUBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureOffset2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetch1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetch1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetch1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetch1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetch1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetch1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetch2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetch2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetch2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetch2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetch2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetch2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetch3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetch3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetch3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetch3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetch3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetch3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetch1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetch1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetch1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetch1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetch1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetch1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetch2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetch2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetch2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetch2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetch2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetch2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetchBufferF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetchBufferF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetchBufferF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetchBufferF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetchBufferF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetchBufferF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetch1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetch1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetch1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetch1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetch1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetch1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetch1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetch1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetch1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetch2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetch2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetch2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetch2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetch2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetch2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetch2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetch2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetch2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetch3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetch3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetch3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetch3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetch3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetch3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetch3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetch3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetch3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetch1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetch1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetch1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetch1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetch1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetch1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetch1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetch1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetch1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetch2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetch2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetch2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetch2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetch2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetch2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetch2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetch2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetch2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetchBufferI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetchBufferI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetchBufferI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetchBufferI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetchBufferI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetchBufferI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetchBufferI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetchBufferI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetchBufferI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetch1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetch1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetch1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetch1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetch1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetch1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetch1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetch1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetch1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetch2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetch2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetch2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetch2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetch2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetch2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetch2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetch2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetch2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetch3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetch3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetch3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetch3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetch3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetch3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetch3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetch3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch3DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetch3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetch1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetch1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetch1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetch1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetch1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetch1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetch1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetch1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch1DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetch1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetch2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetch2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetch2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetch2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetch2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetch2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetch2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetch2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetch2DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetch2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetchBufferU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetchBufferU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetchBufferU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetchBufferU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetchBufferU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetchBufferU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetchBufferU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetchBufferU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Buffer>
	*@param[in] P
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchBufferUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetchBufferU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetchOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetchOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetchOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetchOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetchOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetchOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetchOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetchOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetchOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetchOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetchOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetchOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetchOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetchOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetchOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetchOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetchOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetchOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetchOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetchOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetchOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetchOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetchOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetchOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetchOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTexelFetchOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetchOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTexelFetchOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetchOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexelFetchOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetchOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetchOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetchOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetchOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetchOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetchOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetchOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetchOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetchOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetchOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetchOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetchOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetchOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetchOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetchOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetchOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetchOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetchOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetchOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetchOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetchOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetchOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetchOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetchOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetchOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetchOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetchOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetchOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetchOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetchOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetchOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetchOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetchOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetchOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetchOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetchOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetchOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetchOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTexelFetchOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetchOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetchOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTexelFetchOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetchOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetchOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTexelFetchOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetchOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetchOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetchOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetchOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetchOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetchOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetchOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetchOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetchOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetchOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetchOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetchOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetchOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetchOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetchOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetchOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetchOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetchOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetchOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetchOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetchOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetchOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetchOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetchOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetchOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetchOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset3DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetchOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetchOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetchOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetchOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetchOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetchOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetchOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetchOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetchOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset1DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetchOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetchOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetchOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTexelFetchOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetchOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetchOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTexelFetchOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetchOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetchOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTexelFetchOffset2DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTexelFetchOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF2Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF2Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF2Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF2Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF2R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF2R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF2BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF2BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF2BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF2BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF2BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF2BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF4BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF4BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF4BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF4BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF4BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DF4BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF3Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF3Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF3Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF3Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF3R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF3R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF3BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF3BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF3BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF3BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF3BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF3BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF4BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF4BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF4BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF4BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF4BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DF4BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DFBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DFBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DFBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DFBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI2Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI2Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI2Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI2Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI2Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI2Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI2R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI2R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI2R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI2BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI2BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI2BiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI2BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI2BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI2BiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI2BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI2BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI2BiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI4BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI4BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI4BiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI4BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI4BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI4BiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI4BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI4BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DI4BiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI3Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI3Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI3Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI3Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI3Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI3Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI3R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI3R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI3R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI3BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI3BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI3BiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI3BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI3BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI3BiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI3BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI3BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI3BiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI4BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI4BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI4BiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI4BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI4BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI4BiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI4BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI4BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DI4BiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DIBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DIBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DIBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DIBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DIBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DIBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DIBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DIBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DIBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU2Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU2Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU2Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU2Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU2Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU2Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU2R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU2R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU2R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU2BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU2BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU2BiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU2BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU2BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU2BiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU2BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU2BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU2BiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU4BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU4BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU4BiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU4BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU4BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU4BiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU4BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU4BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DU4BiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU3Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU3Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU3Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU3Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU3Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU3Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU3R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU3R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU3R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU3BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU3BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU3BiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU3BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU3BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU3BiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU3BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU3BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU3BiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU4BiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU4BiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU4BiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU4BiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU4BiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU4BiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU4BiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU4BiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DU4BiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DUBiasRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DUBiasRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DUBiasRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DUBiasRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DUBiasRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DUBiasRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DUBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DUBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset3DUBiasR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLodOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLodOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLodOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLodOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLodOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLodOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLodOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLodOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLodOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLodOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLodOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLodOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLodOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureLodOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLodOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureLodOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureLodOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureLodOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureLodOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset3DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureLodOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureLodOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureLodOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DF2Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLod1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DF2Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLod1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DF2Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLod1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DF2Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLod1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DF2R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLod1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DF2R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLod1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DF4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLod1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DF4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLod1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DF4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLod1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DF4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLod1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DF4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLod1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DF4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLod1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DF3Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLod2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DF3Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLod2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DF3Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLod2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DF3Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLod2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DF3R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLod2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DF3R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLod2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DF4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLod2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DF4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLod2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DF4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLod2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DF4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLod2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DF4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLod2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DF4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLod2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DI2Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLod1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DI2Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLod1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DI2Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLod1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DI2Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLod1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DI2Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLod1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DI2Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLod1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DI2R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLod1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DI2R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLod1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DI2R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLod1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DI4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLod1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DI4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLod1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DI4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLod1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DI4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLod1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DI4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLod1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DI4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLod1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DI4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLod1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DI4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLod1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DI4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLod1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DI3Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLod2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DI3Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLod2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DI3Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLod2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DI3Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLod2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DI3Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLod2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DI3Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLod2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DI3R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLod2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DI3R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLod2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DI3R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLod2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DI4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLod2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DI4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLod2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DI4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLod2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DI4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLod2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DI4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLod2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DI4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLod2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DI4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLod2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DI4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLod2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DI4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLod2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DU2Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLod1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DU2Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLod1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DU2Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLod1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DU2Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLod1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DU2Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLod1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DU2Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLod1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DU2R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLod1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DU2R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLod1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DU2R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLod1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DU4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLod1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DU4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLod1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DU4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLod1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DU4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLod1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DU4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLod1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DU4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLod1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DU4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLod1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DU4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLod1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DU4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLod1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DU3Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLod2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DU3Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLod2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DU3Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLod2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DU3Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLod2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DU3Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLod2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DU3Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLod2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DU3R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLod2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DU3R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLod2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DU3R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLod2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DU4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLod2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DU4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLod2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DU4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLod2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DU4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLod2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DU4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLod2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DU4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLod2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DU4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLod2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DU4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLod2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DU4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLod2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod3DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DF2Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLodOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DF2Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLodOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DF2Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLodOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DF2Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLodOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DF2R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLodOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DF2R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLodOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DF4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLodOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DF4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLodOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DF4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLodOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DF4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLodOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DF4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLodOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DF4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLodOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DF3Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLodOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DF3Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLodOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DF3Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLodOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DF3Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLodOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DF3R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLodOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DF3R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLodOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DF4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLodOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DF4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLodOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DF4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLodOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DF4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLodOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DF4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLodOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DF4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLodOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DI2Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLodOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DI2Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLodOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DI2Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLodOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DI2Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLodOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DI2Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLodOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DI2Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLodOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DI2R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLodOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DI2R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLodOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DI2R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLodOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DI4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLodOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DI4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLodOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DI4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLodOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DI4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLodOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DI4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLodOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DI4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLodOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DI4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLodOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DI4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLodOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DI4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLodOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DI3Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLodOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DI3Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLodOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DI3Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLodOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DI3Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLodOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DI3Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLodOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DI3Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLodOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DI3R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLodOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DI3R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLodOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DI3R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLodOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DI4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLodOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DI4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLodOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DI4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLodOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DI4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLodOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DI4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLodOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DI4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLodOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DI4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLodOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DI4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLodOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DI4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLodOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DU2Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLodOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DU2Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLodOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DU2Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLodOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DU2Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLodOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DU2Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLodOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DU2Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLodOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DU2R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLodOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DU2R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLodOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DU2R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLodOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DU4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLodOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DU4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLodOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DU4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLodOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DU4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLodOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DU4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLodOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DU4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLodOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DU4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLodOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DU4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLodOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DU4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLodOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DU3Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLodOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DU3Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLodOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DU3Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLodOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DU3Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLodOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DU3Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLodOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DU3Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLodOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DU3R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLodOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DU3R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLodOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DU3R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLodOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DU4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLodOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DU4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLodOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DU4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLodOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DU4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLodOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DU4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLodOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DU4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLodOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DU4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLodOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DU4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLodOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DU4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLodOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset3DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGrad1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGrad1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGrad1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGrad1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGrad1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGrad1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGrad2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGrad2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGrad2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGrad2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGrad2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGrad2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGradCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGradCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGradCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGradCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGrad1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGrad1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGrad1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGrad1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGrad1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGrad1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGrad2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGrad2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGrad2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGrad2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGrad2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGrad2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGradCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGradCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGradCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGradCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGrad1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGrad1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGrad1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGrad1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGrad1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGrad1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGrad1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGrad1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGrad1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGrad2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGrad2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGrad2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGrad2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGrad2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGrad2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGrad2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGrad2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGrad2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGrad1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGrad1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGrad1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGrad1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGrad1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGrad1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGrad1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGrad1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGrad1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGrad2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGrad2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGrad2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGrad2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGrad2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGrad2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGrad2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGrad2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGrad2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGrad1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGrad1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGrad1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGrad1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGrad1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGrad1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGrad1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGrad1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGrad1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGrad2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGrad2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGrad2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGrad2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGrad2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGrad2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGrad2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGrad2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGrad2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad3DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGrad1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGrad1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGrad1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGrad1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGrad1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGrad1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGrad1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGrad1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGrad1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGrad2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGrad2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGrad2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGrad2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGrad2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGrad2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGrad2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGrad2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGrad2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureGradCubeArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGradOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGradOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGradOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGradOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGradOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGradOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGradOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGradOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGradOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGradOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGradOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGradOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGradOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGradOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGradOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureGradOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGradOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureGradOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureGradOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset3DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGradOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureGradOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureGradOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DF2Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGrad1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DF2Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGrad1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DF2Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGrad1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DF2Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGrad1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DF2R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGrad1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DF2R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGrad1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DF4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGrad1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DF4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGrad1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DF4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGrad1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DF4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGrad1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DF4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGrad1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DF4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGrad1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DF3Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGrad2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DF3Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGrad2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DF3Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGrad2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DF3Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGrad2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DF3R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGrad2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DF3R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGrad2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DF4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGrad2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DF4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGrad2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DF4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGrad2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DF4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGrad2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DF4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGrad2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DF4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGrad2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DI2Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGrad1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DI2Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGrad1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DI2Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGrad1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DI2Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGrad1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DI2Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGrad1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DI2Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGrad1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DI2R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGrad1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DI2R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGrad1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DI2R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGrad1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DI4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGrad1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DI4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGrad1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DI4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGrad1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DI4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGrad1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DI4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGrad1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DI4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGrad1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DI4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGrad1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DI4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGrad1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DI4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGrad1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DI3Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGrad2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DI3Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGrad2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DI3Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGrad2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DI3Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGrad2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DI3Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGrad2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DI3Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGrad2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DI3R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGrad2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DI3R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGrad2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DI3R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGrad2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DI4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGrad2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DI4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGrad2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DI4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGrad2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DI4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGrad2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DI4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGrad2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DI4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGrad2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DI4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGrad2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DI4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGrad2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DI4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGrad2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DU2Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGrad1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DU2Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGrad1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DU2Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGrad1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DU2Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGrad1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DU2Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGrad1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DU2Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGrad1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DU2R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGrad1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DU2R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGrad1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DU2R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGrad1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DU4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGrad1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DU4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGrad1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DU4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGrad1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DU4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGrad1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DU4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGrad1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DU4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGrad1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DU4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGrad1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DU4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGrad1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DU4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGrad1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DU3Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGrad2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DU3Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGrad2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DU3Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGrad2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DU3Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGrad2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DU3Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGrad2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DU3Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGrad2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DU3R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGrad2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DU3R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGrad2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DU3R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGrad2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DU4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGrad2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DU4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGrad2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DU4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGrad2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DU4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGrad2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DU4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGrad2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DU4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGrad2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DU4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGrad2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DU4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGrad2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DU4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGrad2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad3DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DF2Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGradOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DF2Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGradOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DF2Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGradOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DF2Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGradOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DF2R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGradOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DF2R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGradOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DF4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGradOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DF4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGradOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DF4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGradOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DF4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGradOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DF4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGradOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DF4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGradOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DF3Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGradOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DF3Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGradOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DF3Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGradOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DF3Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGradOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DF3R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGradOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DF3R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGradOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DF4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGradOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DF4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGradOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DF4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGradOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DF4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGradOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DF4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGradOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DF4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGradOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureProjGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2F )
			, CombinedImageAccess::eTextureProjGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DI2Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGradOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DI2Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGradOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DI2Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGradOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DI2Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGradOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DI2Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGradOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DI2Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGradOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DI2R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGradOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DI2R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGradOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DI2R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGradOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DI4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGradOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DI4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGradOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DI4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGradOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DI4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGradOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DI4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGradOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DI4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGradOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DI4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGradOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DI4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGradOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DI4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGradOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DI3Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGradOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DI3Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGradOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DI3Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGradOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DI3Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGradOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DI3Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGradOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DI3Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGradOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DI3R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGradOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DI3R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGradOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DI3R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGradOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DI4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGradOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DI4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGradOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DI4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGradOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DI4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGradOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DI4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGradOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DI4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGradOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DI4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGradOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DI4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGradOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DI4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGradOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureProjGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2I )
			, CombinedImageAccess::eTextureProjGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	CombinedImage<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eInt )
			, CombinedImageAccess::eTextureProjGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DU2Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGradOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DU2Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGradOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DU2Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGradOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DU2Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGradOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DU2Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGradOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DU2Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGradOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DU2R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGradOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DU2R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGradOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DU2R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGradOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DU4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGradOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DU4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGradOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DU4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGradOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DU4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGradOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DU4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGradOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DU4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGradOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DU4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGradOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DU4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGradOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DU4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGradOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DU3Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGradOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DU3Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGradOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DU3Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGradOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DU3Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGradOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DU3Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGradOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DU3Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGradOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DU3R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGradOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DU3R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGradOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DU3R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGradOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DU4Rgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGradOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DU4Rgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGradOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DU4Rgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGradOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DU4Rg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGradOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DU4Rg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGradOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DU4Rg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGradOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DU4R32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGradOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DU4R16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGradOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DU4R8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGradOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureProjGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec2U )
			, CombinedImageAccess::eTextureProjGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	CombinedImage<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset3DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eUInt )
			, CombinedImageAccess::eTextureProjGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}	
	// Texel Compare Functions

	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DShadowFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture1DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DShadowFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture1DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DShadowFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture2DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DShadowFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture2DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureCubeShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureCubeShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeShadowFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureCubeShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeShadowFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureCubeShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayShadowFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture1DArrayShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture1DArrayShadowFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture1DArrayShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTexture2DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTexture2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube, Array, Shadow>
	*@param[in] P
	*	vec4f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureCubeArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube, Array, Shadow>
	*@param[in] P
	*	vec4f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureCubeArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureCubeArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DShadowFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj1DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj1DShadowFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj1DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DShadowFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj2DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProj2DShadowFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProj2DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLod1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLod1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLod2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLod2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodCubeShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodCubeShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLod1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod1DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLod1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLod2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLod2DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLod2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube, Array, Shadow>
	*@param[in] P
	*	vec4f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodCubeArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, Cube, Array, Shadow>
	*@param[in] P
	*	vec4f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureLodCubeArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodCubeArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DShadowFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset1DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DShadowFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset1DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DShadowFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset2DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DShadowFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset2DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset1DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureOffset2DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureOffset2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DShadowFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset1DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset1DShadowFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset1DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DShadowFBiasR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset2DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjOffset2DShadowFBiasR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjOffset2DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset2DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodOffset1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureLodOffset1DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureLodOffset1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLod1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod1DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLod1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLod2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLod2DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLod2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLodOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset1DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLodOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLodOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjLodOffset2DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjLodOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGrad1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGrad1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGrad2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad2DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGrad2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGrad1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGrad1DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGrad1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradOffset1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset1DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradOffset1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradOffset2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGradOffset2DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureGradOffset2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGrad1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad1DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGrad1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGrad2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGrad2DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGrad2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGradOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset1DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGradOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGradOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureProjGradOffset2DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eFloat )
			, CombinedImageAccess::eTextureProjGradOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	// Texture Gather Functions

	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGather2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGather2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGather2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGather2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGather2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGather2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGather2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGather2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGather2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGather2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGather2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGather2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGather2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGather2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGather2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGather2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGather2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGather2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGather2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGather2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGather2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGather2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGather2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGather2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGather2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGather2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGather2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGather2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGather2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGather2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGather2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGather2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGather2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGather2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGather2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGather2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGather2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGather2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGather2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGather2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGather2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGather2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGather2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGather2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGather2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGather2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGather2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGather2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffsets2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffsets2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffsets2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffsets2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffsets2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffsets2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayFRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayFRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayFRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayFRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffsets2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffsets2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffsets2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffsets2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffsets2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffsets2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffsets2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffsets2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffsets2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayIRgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayIRgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayIRgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayIRg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayIRg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayIRg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayIR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayIR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	CombinedImage<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayIR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4I )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffsets2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffsets2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffsets2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffsets2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffsets2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffsets2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffsets2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffsets2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffsets2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayURgba32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayURgba16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayURgba8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayURg32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayURg16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayURg8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayUR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayUR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	CombinedImage<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayUR8( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4U )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	// Texture Gather Compare Functions

	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGather2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGather2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGather2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGather2DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGather2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherCubeShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherCubeShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube, Array, Shadow>
	*@param[in] P
	*	vec4f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherCubeArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, Cube, Array, Shadow>
	*@param[in] P
	*	vec4f
	*@param[in] refZ
	*	float
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherCubeArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherCubeArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffset2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffset2DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffset2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffsets2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffsets2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayShadowFR32( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	CombinedImage<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offsets
	*	vec2i
	*/
	inline CombinedImageAccessCallPtr makeTextureGatherOffsets2DArrayShadowFR16( ExprCache & exprCache
		, type::TypesCache & typesCache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return exprCache.makeCombinedImageAccessCall( typesCache.getBasicType( type::Kind::eVec4F )
			, CombinedImageAccess::eTextureGatherOffsets2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offsets ) );
	}
}

#endif
