/*
See LICENSE file in root folder
*/
/*
This file is generated, don't modify it!
*/
#ifndef ___AST_ExprMakeTextureAccess_H___
#define ___AST_ExprMakeTextureAccess_H___
#pragma once

#include "ExprTextureAccessCall.hpp"

#include <cassert>

namespace ast::expr
{	// Texture Query Functions

	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, Cube, Shadow>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, Cube, Shadow>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, Cube, Array, Shadow>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, Cube, Array, Shadow>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectFRgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectF
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectFRgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectF
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectFRg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectF
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectFRg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectF
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectFR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectF
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectFR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectF
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, Rect, Shadow>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, Rect, Shadow>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, 2D, Array, Shadow>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Float, 2D, Array, Shadow>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayShadowF
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferFRgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferFRgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferFRg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferFRg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferFR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferFR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectIRgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectI
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectIRgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectI
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectIRgba8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectI
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectIRg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectI
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectIRg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectI
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectIRg8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectI
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectIR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectI
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectIR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectI
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectIR8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectI
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayI
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferIRgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferIRgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferIRgba8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferIRg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferIRg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferIRg8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferIR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferIR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferIR8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSize1DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize3DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize3DU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSizeCubeU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSizeCubeArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSizeCubeArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectURgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectU
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectURgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectU
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectURgba8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectU
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectURg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectU
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectURg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectU
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectURg8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectU
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectUR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectU
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectUR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectU
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, Rect>
	*/
	inline TextureAccessCallPtr makeTextureSize2DRectUR8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize2DRectU
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize1DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureSize1DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec3i
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTextureSize2DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr lod )
	{
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec3I )
			, TextureAccess::eTextureSize2DArrayU
			, std::move( texture )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferURgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferURgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferURgba8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferURg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferURg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferURg8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferUR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferUR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Buffer>
	*/
	inline TextureAccessCallPtr makeTextureSizeBufferUR8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureSizeBufferU
			, std::move( texture ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube, Shadow>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube, Shadow>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube, Array, Shadow>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube, Array, Shadow>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayShadowF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod3DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTextureQueryLod1DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureQueryLod2DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLod2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureQueryLodCubeArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureQueryLodCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DFRgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DFRgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DFRg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DFRg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DFR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DFR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DFRgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DFRgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DFRg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DFRg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DFR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DFR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DFRgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DFRgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DFRg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DFRg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DFR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DFR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeFRgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeFRgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeFRg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeFRg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeFR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeFR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayFR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayFR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayFR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayFR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayFRg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayFRg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayFR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayFR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D, Shadow>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DShadowFR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D, Shadow>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DShadowFR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 2D, Shadow>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DShadowFR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 2D, Shadow>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DShadowFR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Cube, Shadow>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeShadowFR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Cube, Shadow>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeShadowFR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 2D, Array, Shadow>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, 2D, Array, Shadow>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Cube, Array, Shadow>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Float, Cube, Array, Shadow>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayShadowF
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DIRgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DIRgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DIRgba8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DIRg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DIRg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DIRg8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DIR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DIR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DIR8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DIRgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DIRgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DIRgba8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DIRg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DIRg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DIRg8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DIR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DIR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DIR8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DIRgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DIRgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DIRgba8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DIRg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DIRg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DIRg8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DIR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DIR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DIR8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeIRgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeIRgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeIRgba8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeIRg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeIRg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeIRg8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeIR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeIR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeIR8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayIR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayIR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayIR8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayIR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayIR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayIR8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayIRg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayIRg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayIRg8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayIR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayIR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayIR8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayI
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DURgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DURgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DURgba8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DURg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DURg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DURg8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DUR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DUR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DUR8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DURgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DURgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DURgba8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DURg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DURg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DURg8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DUR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DUR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 2D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DUR8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DURgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DURgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DURgba8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DURg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DURg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DURg8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DUR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DUR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 3D>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels3DUR8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels3DU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeURgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeURgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeURgba8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeURg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeURg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeURg8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeUR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeUR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Cube>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeUR8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayURg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayURg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayURg8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayUR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayUR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 1D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels1DArrayUR8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels1DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayURg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayURg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayURg8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayUR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayUR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, 2D, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevels2DArrayUR8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevels2DArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayURgba32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayURgba16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayURgba8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayURg32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayURg16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayURg8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayUR32( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayUR16( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayU
			, std::move( texture ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<UInt, Cube, Array>
	*/
	inline TextureAccessCallPtr makeTextureQueryLevelsCubeArrayUR8( type::TypesCache & cache
		, ExprPtr texture )
	{
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureQueryLevelsCubeArrayU
			, std::move( texture ) );
	}
	// Texel Lookup Functions

	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture1DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DFBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DFBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DFBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DFBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture2DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DFBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DFBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DFBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DFBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DFBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DFBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DFBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DFBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureCubeF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeFBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureCubeFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeFBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureCubeFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeFBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureCubeFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeFBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureCubeFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureCubeFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureCubeFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture1DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayFBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayFBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayFBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayFBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture2DArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayFBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayFBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayFBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayFBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureCubeArrayF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayFBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureCubeArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayFBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureCubeArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayFBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureCubeArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayFBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureCubeArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureCubeArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureCubeArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture2DRectF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexture2DRectF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture2DRectF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexture2DRectF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture2DRectF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture2DRectF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture1DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DIBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DIBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DIBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DIBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DIBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DIBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DIBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DIBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DIBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture2DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DIBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DIBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DIBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DIBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DIBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DIBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DIBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DIBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DIBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DIBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DIBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DIBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DIBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DIBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DIBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DIBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DIBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DIBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureCubeI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeIBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureCubeIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeIBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureCubeIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeIBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureCubeIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeIBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureCubeIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeIBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureCubeIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeIBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureCubeIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeIBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureCubeIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeIBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureCubeIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeIBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureCubeIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture1DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayIBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayIBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayIBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayIBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayIBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayIBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayIBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayIBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayIBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture2DArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayIBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayIBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayIBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayIBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayIBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayIBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayIBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayIBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayIBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureCubeArrayI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayIBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureCubeArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayIBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureCubeArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayIBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureCubeArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayIBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureCubeArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayIBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureCubeArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayIBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureCubeArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayIBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureCubeArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayIBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureCubeArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayIBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureCubeArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture2DRectI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture2DRectI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexture2DRectI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture2DRectI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture2DRectI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexture2DRectI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture2DRectI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture2DRectI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexture2DRectI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture1DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DUBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DUBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DUBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DUBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DUBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DUBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DUBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DUBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DUBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture2DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DUBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DUBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DUBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DUBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DUBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DUBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DUBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DUBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DUBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture3DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DUBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DUBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DUBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DUBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DUBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DUBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DUBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DUBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture3DUBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureCubeUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureCubeU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeUBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureCubeUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeUBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureCubeUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeUBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureCubeUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeUBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureCubeUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeUBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureCubeUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeUBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureCubeUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeUBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureCubeUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeUBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureCubeUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeUBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureCubeUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture1DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture1DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayUBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayUBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayUBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayUBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayUBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayUBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayUBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayUBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayUBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTexture2DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture2DArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayUBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayUBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayUBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayUBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayUBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayUBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayUBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayUBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayUBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureCubeArrayU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayUBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureCubeArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayUBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureCubeArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayUBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureCubeArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayUBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureCubeArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayUBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureCubeArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayUBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureCubeArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayUBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureCubeArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayUBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureCubeArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayUBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureCubeArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture2DRectU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture2DRectU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexture2DRectU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture2DRectU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture2DRectU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexture2DRectU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture2DRectU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture2DRectU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTexture2DRectUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexture2DRectU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DF2Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj1DF2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DF2Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj1DF2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DF2Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj1DF2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DF2Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj1DF2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DF2R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj1DF2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DF2R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj1DF2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DF2BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DF2BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DF2BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DF2BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DF2BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DF2BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DF4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj1DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DF4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj1DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DF4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj1DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DF4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj1DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DF4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj1DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DF4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj1DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DF4BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DF4BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DF4BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DF4BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DF4BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DF4BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DF3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj2DF3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DF3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj2DF3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DF3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj2DF3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DF3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj2DF3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DF3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj2DF3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DF3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj2DF3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DF3BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DF3BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DF3BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DF3BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DF3BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DF3BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DF4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj2DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DF4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj2DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DF4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj2DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DF4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj2DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DF4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj2DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DF4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj2DF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DF4BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DF4BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DF4BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DF4BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DF4BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DF4BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj3DF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DFBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DFBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DFBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DFBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectF3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj2DRectF3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectF3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj2DRectF3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectF3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj2DRectF3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectF3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj2DRectF3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectF3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj2DRectF3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectF3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj2DRectF3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectF4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj2DRectF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectF4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProj2DRectF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectF4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj2DRectF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectF4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProj2DRectF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectF4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj2DRectF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectF4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj2DRectF4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DI2Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj1DI2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DI2Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj1DI2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DI2Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj1DI2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DI2Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj1DI2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DI2Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj1DI2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DI2Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj1DI2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DI2R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj1DI2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DI2R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj1DI2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DI2R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj1DI2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DI2BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DI2BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DI2BiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DI2BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DI2BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DI2BiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DI2BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DI2BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DI2BiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DI4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj1DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DI4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj1DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DI4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj1DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DI4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj1DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DI4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj1DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DI4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj1DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DI4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj1DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DI4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj1DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DI4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj1DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DI4BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DI4BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DI4BiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DI4BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DI4BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DI4BiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DI4BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DI4BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DI4BiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DI3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj2DI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DI3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj2DI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DI3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj2DI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DI3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj2DI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DI3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj2DI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DI3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj2DI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DI3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj2DI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DI3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj2DI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DI3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj2DI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DI3BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DI3BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DI3BiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DI3BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DI3BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DI3BiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DI3BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DI3BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DI3BiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DI4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj2DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DI4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj2DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DI4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj2DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DI4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj2DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DI4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj2DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DI4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj2DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DI4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj2DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DI4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj2DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DI4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj2DI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DI4BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DI4BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DI4BiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DI4BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DI4BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DI4BiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DI4BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DI4BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DI4BiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj3DI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DIBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DIBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DIBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DIBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DIBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DIBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DIBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DIBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DIBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectI3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj2DRectI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectI3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj2DRectI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectI3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj2DRectI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectI3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj2DRectI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectI3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj2DRectI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectI3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj2DRectI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectI3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj2DRectI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectI3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj2DRectI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectI3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj2DRectI3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectI4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj2DRectI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectI4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj2DRectI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectI4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProj2DRectI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectI4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj2DRectI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectI4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj2DRectI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectI4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProj2DRectI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectI4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj2DRectI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectI4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj2DRectI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectI4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProj2DRectI4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DU2Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj1DU2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DU2Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj1DU2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DU2Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj1DU2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DU2Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj1DU2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DU2Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj1DU2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DU2Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj1DU2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DU2R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj1DU2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DU2R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj1DU2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProj1DU2R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj1DU2
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DU2BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DU2BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DU2BiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DU2BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DU2BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DU2BiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DU2BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DU2BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DU2BiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DU4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj1DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DU4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj1DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DU4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj1DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DU4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj1DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DU4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj1DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DU4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj1DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DU4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj1DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DU4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj1DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj1DU4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj1DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DU4BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DU4BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DU4BiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DU4BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DU4BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DU4BiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DU4BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DU4BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DU4BiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DU3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj2DU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DU3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj2DU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DU3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj2DU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DU3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj2DU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DU3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj2DU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DU3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj2DU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DU3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj2DU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DU3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj2DU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DU3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj2DU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DU3BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DU3BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DU3BiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DU3BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DU3BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DU3BiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DU3BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DU3BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DU3BiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DU4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj2DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DU4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj2DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DU4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj2DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DU4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj2DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DU4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj2DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DU4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj2DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DU4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj2DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DU4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj2DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DU4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj2DU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DU4BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DU4BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DU4BiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DU4BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DU4BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DU4BiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DU4BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DU4BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DU4BiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj3DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj3DU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DUBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DUBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DUBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DUBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DUBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DUBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DUBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DUBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj3DUBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectU3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj2DRectU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectU3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj2DRectU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectU3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj2DRectU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectU3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj2DRectU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectU3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj2DRectU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectU3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj2DRectU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectU3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj2DRectU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectU3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj2DRectU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectU3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj2DRectU3
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectU4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj2DRectU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectU4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj2DRectU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectU4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProj2DRectU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectU4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj2DRectU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectU4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj2DRectU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectU4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProj2DRectU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectU4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj2DRectU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectU4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj2DRectU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectU4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProj2DRectU4
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLod1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLod1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLod1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLod1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLod1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLod1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLod2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLod2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLod2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLod2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLod2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLod2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLodCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLodCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLodCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLodCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLod1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLod1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLod1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLod1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLod1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLod1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLod2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLod2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLod2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLod2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLod2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLod2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLodCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLodCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLodCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLodCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLod1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLod1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLod1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLod1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLod1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLod1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLod1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLod1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLod1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLod2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLod2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLod2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLod2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLod2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLod2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLod2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLod2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLod2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLod1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLod1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLod1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLod1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLod1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLod1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLod1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLod1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLod1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLod2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLod2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLod2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLod2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLod2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLod2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLod2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLod2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLod2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLod1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLod1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLod1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLod1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLod1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLod1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLod1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLod1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLod1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLod2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLod2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLod2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLod2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLod2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLod2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLod2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLod2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLod2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod3DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLod1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLod1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLod1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLod1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLod1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLod1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLod1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLod1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLod1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLod2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLod2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLod2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLod2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLod2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLod2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLod2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLod2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLod2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLodCubeArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DFBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DFBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DFBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DFBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset1DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DFBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DFBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DFBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DFBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset2DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DFBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DFBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DFBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DFBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayFBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayFBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayFBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayFBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset1DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayFBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayFBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureOffset2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayFBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayFBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureOffset2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset2DArrayFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DIBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DIBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DIBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DIBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DIBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DIBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DIBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DIBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DIBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset1DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DIBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DIBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DIBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DIBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DIBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DIBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DIBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DIBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DIBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset2DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DIBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DIBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DIBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DIBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DIBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DIBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DIBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DIBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DIBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayIBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayIBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayIBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayIBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayIBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayIBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayIBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayIBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayIBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset1DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayIBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayIBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayIBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureOffset2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayIBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayIBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayIBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureOffset2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayIBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayIBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayIBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureOffset2DArrayIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DUBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DUBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DUBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DUBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DUBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DUBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DUBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DUBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DUBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset1DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DUBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DUBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DUBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DUBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DUBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DUBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DUBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DUBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DUBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset2DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureOffset3DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DUBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DUBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DUBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DUBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DUBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DUBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DUBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DUBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset3DUBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayUBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayUBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayUBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayUBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayUBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayUBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayUBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayUBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayUBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset1DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayUBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayUBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayUBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureOffset2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayUBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayUBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayUBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureOffset2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayUBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayUBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayUBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureOffset2DArrayUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetch1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetch1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetch1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetch1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetch1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetch1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetch2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetch2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetch2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetch2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetch2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetch2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetch3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetch3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetch3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetch3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetch3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetch3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetch2DRectF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetch2DRectF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetch2DRectF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetch2DRectF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetch2DRectF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetch2DRectF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetch1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetch1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetch1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetch1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetch1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetch1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetch2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetch2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetch2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetch2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetch2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetch2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetchBufferF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetchBufferF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetchBufferF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetchBufferF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetchBufferF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetchBufferF
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetch1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetch1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetch1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetch1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetch1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetch1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetch1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetch1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetch1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetch2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetch2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetch2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetch2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetch2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetch2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetch2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetch2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetch2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetch3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetch3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetch3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetch3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetch3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetch3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetch3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetch3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetch3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetch2DRectI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetch2DRectI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetch2DRectI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetch2DRectI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetch2DRectI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetch2DRectI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetch2DRectI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetch2DRectI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetch2DRectI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetch1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetch1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetch1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetch1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetch1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetch1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetch1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetch1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetch1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetch2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetch2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetch2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetch2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetch2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetch2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetch2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetch2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetch2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchBufferI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchBufferI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchBufferI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchBufferI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchBufferI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchBufferI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchBufferI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchBufferI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchBufferI
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetch1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetch1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetch1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetch1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetch1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetch1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetch1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetch1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetch1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetch2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetch2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetch2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetch2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetch2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetch2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetch2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetch2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetch2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetch3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetch3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetch3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetch3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetch3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetch3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetch3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetch3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch3DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetch3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetch2DRectU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetch2DRectU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetch2DRectU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetch2DRectU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetch2DRectU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetch2DRectU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetch2DRectU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetch2DRectU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetch2DRectUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetch2DRectU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetch1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetch1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetch1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetch1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetch1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetch1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetch1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetch1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch1DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetch1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetch2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetch2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetch2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetch2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetch2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetch2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetch2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetch2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetch2DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetch2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchBufferU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchBufferU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchBufferU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchBufferU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchBufferU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchBufferU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchBufferU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchBufferU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Buffer>
	*@param[in] P
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchBufferUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchBufferU
			, std::move( texture )
			, std::move( P ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetchOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetchOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetchOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetchOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetchOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetchOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetchOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetchOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetchOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetchOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetchOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetchOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetchOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetchOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetchOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetchOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetchOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetchOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetchOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetchOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetchOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetchOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetchOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetchOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetchOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetchOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetchOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetchOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetchOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetchOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetchOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTexelFetchOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetchOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTexelFetchOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetchOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexelFetchOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTexelFetchOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTexelFetchOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTexelFetchOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	int
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eInt );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset3DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2i
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DRectUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset1DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTexelFetchOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTexelFetchOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3i
	*@param[in] lod
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTexelFetchOffset2DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3I );
		assert( lod->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTexelFetchOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF2Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF2Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF2Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF2Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF2R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF2R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF2BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF2BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF2BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF2BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF2BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF2BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset1DF2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF4BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF4BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF4BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF4BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF4BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DF4BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset1DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF3BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF3BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF3BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF3BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF3BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF3BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset2DF3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF4BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF4BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF4BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF4BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF4BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DF4BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset2DF4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DFBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DFBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DFBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DFBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset3DFBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectF3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset2DRectF3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectF3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset2DRectF3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectF3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset2DRectF3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectF3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset2DRectF3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectF3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset2DRectF3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectF3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset2DRectF3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectF4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset2DRectF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectF4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjOffset2DRectF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectF4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset2DRectF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectF4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjOffset2DRectF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectF4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset2DRectF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectF4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset2DRectF4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI2Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI2Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI2Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI2Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI2Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI2Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI2R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI2R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI2R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI2BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI2BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI2BiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI2BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI2BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI2BiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI2BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI2BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI2BiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset1DI2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI4BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI4BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI4BiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI4BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI4BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI4BiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI4BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI4BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DI4BiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset1DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI3BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI3BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI3BiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI3BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI3BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI3BiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI3BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI3BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI3BiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset2DI3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI4BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI4BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI4BiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI4BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI4BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI4BiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI4BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI4BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DI4BiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset2DI4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DIBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DIBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DIBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DIBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DIBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DIBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DIBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DIBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DIBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset3DIBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectI3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectI3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectI3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectI3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectI3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectI3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectI3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectI3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectI3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectI4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectI4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectI4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjOffset2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectI4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectI4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectI4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjOffset2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectI4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectI4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectI4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjOffset2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU2Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU2Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU2Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU2Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU2Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU2Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU2R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU2R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU2R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU2BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU2BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU2BiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU2BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU2BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU2BiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU2BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU2BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU2BiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset1DU2Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU4BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU4BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU4BiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU4BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU4BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU4BiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU4BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU4BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DU4BiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset1DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU3BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU3BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU3BiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU3BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU3BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU3BiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU3BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU3BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU3BiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset2DU3Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU4BiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU4BiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU4BiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU4BiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU4BiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU4BiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU4BiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU4BiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DU4BiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset2DU4Bias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DUBiasRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DUBiasRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DUBiasRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DUBiasRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DUBiasRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DUBiasRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DUBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DUBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec3i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset3DUBiasR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset3DUBias
			, std::move( texture )
			, std::move( P )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectU3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectU3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectU3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectU3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectU3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectU3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectU3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectU3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectU3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectU4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectU4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectU4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjOffset2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectU4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectU4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectU4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjOffset2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectU4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectU4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectU4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjOffset2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLodOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLodOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLodOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLodOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLodOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLodOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLodOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLodOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLodOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLodOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLodOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLodOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLodOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureLodOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLodOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureLodOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureLodOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureLodOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureLodOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset3DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureLodOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureLodOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureLodOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DF2Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLod1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DF2Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLod1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DF2Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLod1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DF2Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLod1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DF2R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLod1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DF2R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLod1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DF4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLod1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DF4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLod1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DF4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLod1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DF4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLod1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DF4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLod1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DF4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLod1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DF3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLod2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DF3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLod2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DF3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLod2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DF3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLod2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DF3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLod2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DF3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLod2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DF4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLod2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DF4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLod2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DF4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLod2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DF4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLod2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DF4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLod2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DF4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLod2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLod3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DI2Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLod1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DI2Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLod1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DI2Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLod1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DI2Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLod1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DI2Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLod1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DI2Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLod1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DI2R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLod1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DI2R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLod1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DI2R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLod1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DI4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLod1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DI4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLod1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DI4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLod1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DI4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLod1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DI4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLod1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DI4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLod1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DI4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLod1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DI4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLod1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DI4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLod1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DI3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLod2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DI3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLod2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DI3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLod2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DI3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLod2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DI3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLod2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DI3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLod2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DI3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLod2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DI3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLod2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DI3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLod2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DI4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLod2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DI4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLod2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DI4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLod2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DI4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLod2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DI4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLod2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DI4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLod2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DI4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLod2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DI4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLod2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DI4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLod2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLod3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DU2Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLod1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DU2Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLod1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DU2Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLod1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DU2Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLod1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DU2Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLod1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DU2Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLod1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DU2R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLod1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DU2R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLod1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DU2R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLod1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DU4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLod1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DU4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLod1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DU4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLod1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DU4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLod1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DU4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLod1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DU4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLod1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DU4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLod1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DU4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLod1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DU4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLod1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DU3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLod2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DU3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLod2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DU3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLod2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DU3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLod2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DU3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLod2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DU3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLod2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DU3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLod2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DU3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLod2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DU3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLod2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DU4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLod2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DU4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLod2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DU4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLod2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DU4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLod2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DU4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLod2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DU4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLod2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DU4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLod2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DU4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLod2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DU4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLod2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod3DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLod3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DF2Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLodOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DF2Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLodOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DF2Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLodOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DF2Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLodOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DF2R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLodOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DF2R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLodOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DF4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLodOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DF4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLodOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DF4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLodOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DF4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLodOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DF4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLodOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DF4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLodOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DF3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLodOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DF3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLodOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DF3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLodOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DF3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLodOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DF3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLodOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DF3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLodOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DF4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLodOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DF4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLodOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DF4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLodOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DF4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLodOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DF4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLodOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DF4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLodOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLodOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DI2Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLodOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DI2Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLodOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DI2Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLodOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DI2Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLodOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DI2Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLodOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DI2Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLodOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DI2R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLodOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DI2R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLodOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DI2R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLodOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DI4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLodOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DI4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLodOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DI4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLodOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DI4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLodOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DI4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLodOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DI4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLodOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DI4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLodOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DI4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLodOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DI4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLodOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DI3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLodOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DI3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLodOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DI3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLodOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DI3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLodOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DI3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLodOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DI3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLodOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DI3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLodOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DI3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLodOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DI3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLodOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DI4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLodOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DI4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLodOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DI4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLodOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DI4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLodOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DI4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLodOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DI4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLodOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DI4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLodOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DI4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLodOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DI4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLodOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjLodOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DU2Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLodOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DU2Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLodOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DU2Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLodOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DU2Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLodOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DU2Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLodOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DU2Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLodOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DU2R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLodOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DU2R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLodOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DU2R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLodOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DU4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLodOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DU4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLodOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DU4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLodOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DU4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLodOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DU4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLodOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DU4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLodOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DU4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLodOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DU4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLodOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DU4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLodOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DU3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLodOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DU3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLodOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DU3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLodOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DU3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLodOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DU3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLodOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DU3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLodOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DU3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLodOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DU3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLodOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DU3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLodOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DU4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLodOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DU4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLodOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DU4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLodOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DU4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLodOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DU4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLodOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DU4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLodOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DU4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLodOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DU4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLodOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DU4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLodOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset3DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjLodOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGrad1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGrad1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGrad1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGrad1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGrad2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGrad2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGrad2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGrad2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGradCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGradCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGradCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGradCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGrad2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGrad2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGrad2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGrad2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGrad1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGrad1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGrad1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGrad1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGrad2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGrad2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGrad2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGrad2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGradCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGradCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGradCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGradCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGrad1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGrad1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGrad1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGrad1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGrad1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGrad1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGrad1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGrad1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGrad1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGrad2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGrad2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGrad2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGrad2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGrad2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGrad2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGrad2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGrad2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGrad2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGrad2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGrad2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGrad2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGrad2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGrad2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGrad2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGrad2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGrad2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGrad2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGrad1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGrad1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGrad1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGrad1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGrad1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGrad1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGrad1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGrad1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGrad1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGrad2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGrad2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGrad2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGrad2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGrad2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGrad2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGrad2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGrad2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGrad2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGrad1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGrad1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGrad1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGrad1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGrad1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGrad1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGrad1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGrad1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGrad1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGrad2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGrad2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGrad2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGrad2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGrad2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGrad2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGrad2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGrad2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGrad2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGrad3DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGrad2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGrad2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGrad2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGrad2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGrad2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGrad2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGrad2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGrad2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGrad2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGrad1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGrad1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGrad1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGrad1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGrad1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGrad1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGrad1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGrad1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGrad1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGrad2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGrad2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGrad2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGrad2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGrad2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGrad2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGrad2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGrad2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGrad2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureGradCubeArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGradOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGradOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGradOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGradOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset1DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGradOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGradOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGradOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGradOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGradOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGradOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGradOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGradOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGradOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGradOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGradOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGradOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset1DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGradOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGradOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGradOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureGradOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradOffset1DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradOffset1DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGradOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureGradOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureGradOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradOffset1DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset3DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D, Array>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradOffset1DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGradOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureGradOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureGradOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DF2Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGrad1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DF2Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGrad1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DF2Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGrad1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DF2Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGrad1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DF2R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DF2R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DF4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGrad1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DF4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGrad1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DF4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGrad1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DF4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGrad1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DF4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DF4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DF3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGrad2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DF3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGrad2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DF3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGrad2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DF3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGrad2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DF3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DF3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DF4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGrad2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DF4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGrad2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DF4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGrad2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DF4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGrad2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DF4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DF4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad3DF
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectF3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGrad2DRectF3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectF3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGrad2DRectF3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectF3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGrad2DRectF3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectF3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGrad2DRectF3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectF3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad2DRectF3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectF3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad2DRectF3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectF4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGrad2DRectF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectF4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGrad2DRectF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectF4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGrad2DRectF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectF4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGrad2DRectF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectF4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad2DRectF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectF4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad2DRectF4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DI2Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DI2Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DI2Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DI2Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DI2Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DI2Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DI2R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DI2R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DI2R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DI4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DI4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DI4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DI4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DI4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DI4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DI4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DI4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DI4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DI3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DI3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DI3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DI3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DI3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DI3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DI3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DI3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DI3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DI4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DI4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DI4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DI4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DI4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DI4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DI4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DI4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DI4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad3DI
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectI3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectI3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectI3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectI3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectI3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectI3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectI3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectI3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectI3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectI4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectI4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectI4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGrad2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectI4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectI4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectI4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGrad2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectI4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectI4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectI4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGrad2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DU2Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DU2Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DU2Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DU2Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DU2Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DU2Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DU2R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DU2R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DU2R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DU4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DU4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DU4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DU4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DU4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DU4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DU4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DU4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DU4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DU3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DU3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DU3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DU3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DU3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DU3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DU3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DU3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DU3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DU4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DU4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DU4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DU4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DU4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DU4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DU4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DU4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DU4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec3f
	*@param[in] pDy
	*	vec3f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad3DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec3F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad3DU
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectU3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectU3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectU3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectU3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectU3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectU3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectU3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectU3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectU3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectU4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectU4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectU4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGrad2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectU4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectU4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectU4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGrad2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectU4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectU4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectU4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGrad2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DF2Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGradOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DF2Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGradOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DF2Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGradOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DF2Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGradOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DF2R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DF2R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset1DF2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DF4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGradOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DF4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGradOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DF4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGradOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DF4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGradOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DF4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DF4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset1DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DF3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGradOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DF3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGradOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DF3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGradOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DF3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGradOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DF3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DF3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset2DF3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DF4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGradOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DF4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGradOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DF4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGradOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DF4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGradOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DF4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DF4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset2DF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset3DF
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectF3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGradOffset2DRectF3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectF3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGradOffset2DRectF3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectF3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGradOffset2DRectF3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectF3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGradOffset2DRectF3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectF3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset2DRectF3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectF3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset2DRectF3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectF4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGradOffset2DRectF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectF4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureProjGradOffset2DRectF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectF4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGradOffset2DRectF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectF4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2F )
			, TextureAccess::eTextureProjGradOffset2DRectF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectF4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset2DRectF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectF4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset2DRectF4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DI2Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DI2Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DI2Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DI2Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DI2Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DI2Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DI2R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DI2R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DI2R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset1DI2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DI4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DI4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DI4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DI4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DI4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DI4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DI4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DI4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DI4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset1DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DI3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DI3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DI3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DI3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DI3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DI3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DI3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DI3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DI3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset2DI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DI4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DI4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DI4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DI4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DI4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DI4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DI4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DI4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DI4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset2DI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset3DI
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectI3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectI3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectI3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectI3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectI3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectI3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectI3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectI3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectI3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset2DRectI3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectI4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectI4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectI4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureProjGradOffset2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectI4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectI4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectI4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2I )
			, TextureAccess::eTextureProjGradOffset2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectI4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectI4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	int
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectI4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eInt )
			, TextureAccess::eTextureProjGradOffset2DRectI4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DU2Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DU2Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DU2Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DU2Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DU2Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DU2Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DU2R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DU2R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec2f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DU2R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset1DU2
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DU4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DU4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DU4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DU4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DU4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DU4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DU4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DU4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 1D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DU4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset1DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DU3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DU3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DU3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DU3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DU3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DU3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DU3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DU3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DU3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset2DU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DU4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DU4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DU4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DU4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DU4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DU4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DU4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DU4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DU4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset2DU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, 3D>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec3f
	*@param[in] dPdy
	*	vec3f
	*@param[in] offset
	*	vec3i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset3DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec3F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec3I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset3DU
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectU3Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectU3Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectU3Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectU3Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectU3Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectU3Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectU3R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectU3R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec3f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectU3R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset2DRectU3
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectU4Rgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectU4Rgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectU4Rgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureProjGradOffset2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectU4Rg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectU4Rg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec2u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectU4Rg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec2U )
			, TextureAccess::eTextureProjGradOffset2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectU4R32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectU4R16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	uint
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec4f
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectU4R8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eUInt )
			, TextureAccess::eTextureProjGradOffset2DRectU4
			, std::move( texture )
			, std::move( P )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}	
	// Texel Compare Functions

	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DShadowFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture1DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DShadowFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture1DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DShadowFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture2DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DShadowFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture2DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureCubeShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureCubeShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeShadowFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureCubeShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeShadowFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureCubeShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayShadowFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture1DArrayShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTexture1DArrayShadowFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture1DArrayShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTexture2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTexture2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube, Array, Shadow>
	*@param[in] P
	*	vec4f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureCubeArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Cube, Array, Shadow>
	*@param[in] P
	*	vec4f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureCubeArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureCubeArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DShadowFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj1DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj1DShadowFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj1DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DShadowFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj2DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DShadowFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj2DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProj2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProj2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLod1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLod1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLod2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod2DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLod2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLod1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureLod1DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLod1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DShadowFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset1DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset1DShadowFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset1DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DShadowFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset2DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureOffset2DShadowFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset2DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureOffset1DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureOffset2DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureOffset2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DShadowFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset1DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	int
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset1DShadowFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset1DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DShadowFBiasR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset2DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*@param[in] bias
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DShadowFBiasR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset
		, ExprPtr bias )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		assert( bias->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset2DShadowFBias
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset )
			, std::move( bias ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjOffset2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjOffset2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureLodOffset2DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodOffset1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureLodOffset1DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureLodOffset1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLod1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod1DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLod1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLod2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjLod2DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLod2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLodOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset1DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLodOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLodOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] lod
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjLodOffset2DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr lod
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( lod->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjLodOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( lod )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureGrad2DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGrad1DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGrad1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	float
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eFloat );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Array, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGradOffset1DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset1DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGradOffset2DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureGradOffset2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] pDx
	*	float
	*@param[in] pDy
	*	float
	*/
	inline TextureAccessCallPtr makeTextureProjGrad1DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDx->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDy->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] pDx
	*	vec2f
	*@param[in] pDy
	*	vec2f
	*/
	inline TextureAccessCallPtr makeTextureProjGrad2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr pDx
		, ExprPtr pDy )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( pDx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( pDy->getType()->getRawKind() == type::Kind::eVec2F );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGrad2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( pDx )
			, std::move( pDy ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 1D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	float
	*@param[in] dPdy
	*	float
	*@param[in] offset
	*	int
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset1DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdy->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset1DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	/**
	*@return
	*	float
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] dPdx
	*	vec2f
	*@param[in] dPdy
	*	vec2f
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureProjGradOffset2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr dPdx
		, ExprPtr dPdy
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( dPdx->getType()->getRawKind() == type::Kind::eVec2F );
		assert( dPdy->getType()->getRawKind() == type::Kind::eVec2F );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eFloat )
			, TextureAccess::eTextureProjGradOffset2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( dPdx )
			, std::move( dPdy )
			, std::move( offset ) );
	}
	// Texture Gather Functions

	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherCubeF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherCubeArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherCubeI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherCubeArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGather2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherCubeU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Cube, Array>
	*@param[in] P
	*	vec4f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherCubeArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGather2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffset2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffset2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DArrayF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectFRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectFRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectFRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectFRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DRectF
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DArrayI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectIRgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectIRgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectIRgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectIRg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectIRg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectIRg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectIR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectIR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4i
	*@param image
	*	Texture<Int, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectIR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4I )
			, TextureAccess::eTextureGatherOffsets2DRectI
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, 2D, Array>
	*@param[in] P
	*	vec3f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DArrayU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectURgba32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectURgba16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectURgba8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectURg32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectURg16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectURg8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectUR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectUR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4u
	*@param image
	*	Texture<UInt, Rect>
	*@param[in] P
	*	vec2f
	*@param[in] comp
	*	int
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectUR8( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr comp
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( comp->getType()->getRawKind() == type::Kind::eInt );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4U )
			, TextureAccess::eTextureGatherOffsets2DRectU
			, std::move( texture )
			, std::move( P )
			, std::move( comp )
			, std::move( offsets ) );
	}
	// Texture Gather Compare Functions

	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGather2DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGather2DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGather2DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherCubeShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherCubeShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube, Array, Shadow>
	*@param[in] P
	*	vec4f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherCubeArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Cube, Array, Shadow>
	*@param[in] P
	*	vec4f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGatherCubeArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec4F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherCubeArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*/
	inline TextureAccessCallPtr makeTextureGather2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGather2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offset
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffset2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offset )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offset->getType()->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffset2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offset ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, 2D, Array, Shadow>
	*@param[in] P
	*	vec3f
	*@param[in] refZ
	*	float
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DArrayShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec3F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DArrayShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectShadowFR32( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offsets ) );
	}
	/**
	*@return
	*	vec4f
	*@param image
	*	Texture<Float, Rect, Shadow>
	*@param[in] P
	*	vec2f
	*@param[in] refZ
	*	float
	*@param[in] offsets
	*	vec2i
	*/
	inline TextureAccessCallPtr makeTextureGatherOffsets2DRectShadowFR16( type::TypesCache & cache
		, ExprPtr texture
		, ExprPtr P
		, ExprPtr refZ
		, ExprPtr offsets )
	{
		assert( P->getType()->getRawKind() == type::Kind::eVec2F );
		assert( refZ->getType()->getRawKind() == type::Kind::eFloat );
		assert( offsets->getType()->getRawKind() == type::Kind::eArray );
		assert( type::getNonArrayType( offsets->getType() )->getRawKind() == type::Kind::eVec2I );
		return makeTextureAccessCall( cache.getBasicType( type::Kind::eVec4F )
			, TextureAccess::eTextureGatherOffsets2DRectShadowF
			, std::move( texture )
			, std::move( P )
			, std::move( refZ )
			, std::move( offsets ) );
	}
}

#endif
